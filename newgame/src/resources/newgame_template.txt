use crate::types::*;
use serde_json;
use toybox_core;
use toybox_core::{
    AleAction,
    graphics::Drawable,
    QueryError
};

impl Default for $CLASSNAME { 
    fn default() -> Self {
        $CLASSNAME {
            // TODO
            // In types.rs, there will be a struct called $CLASSNAME
            // You should populate it with the necessary game-specific fields 
            // and their types, and document them there. 
            // Then add default values for those fields here.
        }
    }
}

impl Default for StateCore {
    fn default() -> Self {
        StateCore {
            // TODO
            // Replace these with game-appropriate defaults. This is a 
            // temporary solution to get the autogenerated code to compile.
            score: -1,
            lives: -1, 
            level: -1,
            is_dead: false,
        }
    }
}

impl toybox_core::Simulation for $CLASSNAME {
    /// Seed simulation.
    fn reset_seed(&mut self, seed: u32) {
        // TODO
        // Implement this if your game has randomness (if it does not, you can skip)
        // This is typically done by adding a field onto the $CLASSNAME struct
    }

    /// Generate a new State. This is in a Box<State> because it may be 1 of many unknown types as far as calling code is concerned.
    fn new_game(&mut self) -> Box<dyn toybox_core::State> {
        Box::new(State {
            config: self.clone(),
            state: StateCore::default(),
        })
    }

    /// Generate a new State from JSON String (usually modified from a dump of State::to_json).
    fn new_state_from_json(&self, json: &str) -> Result<Box<dyn toybox_core::State>, serde_json::Error> {
        let state: StateCore = serde_json::from_str(json)?;
        Ok(Box::new(State {
            config: self.clone(),
            state
        }))
    }

    /// Return a tuple of game size in pixels, e.g., (100,100).
    fn game_size(&self) -> (i32, i32) {
        // TODO
        // update this as needed/appropriate
        (100, 100)
    }

    /// This serializes the "config" for a game to json.
    fn to_json(&self) -> String {
        serde_json::to_string(&self).expect("Should be no JSON Serialization Errors.")
    }

    /// This deserializes the "config" for a game from json.
    /// Generate new state and new config from JSON String.
    fn from_json(&self, json: &str) -> Result<Box<dyn toybox_core::Simulation>, serde_json::Error> {
        let config: $CLASSNAME = serde_json::from_str(json)?;
        Ok(Box::new(config))

    }

    /// Legal action set:
    fn legal_action_set(&self) -> Vec<AleAction> {
        // TODO
        // Update this; you may want to use ALE actions. See 
        // other games for examples.
        vec![]
    }

    /// Getter for JSON Schema for this game's state.
    fn schema_for_state(&self) -> String {
        let schema = schema_for!(StateCore);
        serde_json::to_string(&schema).expect("JSONSchema should be flawless.")
    }

    /// Getter for JSON Schema for this game's config.
    fn schema_for_config(&self) -> String {
        let schema = schema_for!($CLASSNAME);
        serde_json::to_string(&schema).expect("JSONSchema should be flawless.")
    }

}

impl toybox_core::State for State {
    /// Returns whether we are dead in the current state (will need to issue a FIRE command to consume another life)
    fn is_dead(&self) -> bool { 
        false 
    }
    /// When < 0, this state should be replaced with a call to new_game() on the simulation.
    fn lives(&self) -> i32 {
        // TODO
        -1
    }
    /// Get the score from the game, i32 allows for negative scores.
    fn score(&self) -> i32 {
        // TODO
        -1
    }
    /// Get the level from the game.
    fn level(&self) -> i32 {
        // TODO
        -1
    }
    /// To update internally to the next state, we pass buttons to internal logic.
    fn update_mut(&mut self, buttons: toybox_core::Input) {
        // TODO
    }
    /// Any state can create a vector of drawable objects to present itself.
    fn draw(&self) -> Vec<Drawable> {
        // TODO
        Vec::new()
    }
    /// Any state can serialize to JSON String.
    fn to_json(&self) -> String {
        serde_json::to_string(&self.state).expect("Should be no JSON Serialization Errors.")
    }
    /// Copy this state to save it for later.
    fn copy(&self) -> Box<dyn toybox_core::State> {
        Box::new(self.clone())
    }
    /// Submit a query to this state object, returning a JSON String or error message.
    fn query_json(&self, query: &str, args: &serde_json::Value) -> Result<String, QueryError> {
        // TODO
        // This is used for fast object inspection and is not necessary. Only implement 
        // once you have finished game development and need higher-performance observations
        // of game features/objects.
        Ok("TODO".to_string())
    }
}